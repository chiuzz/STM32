//*
//*********************************************************************************************************
//*
//*                                                 LOGO
//*
//*
//* 文 件 名 : ModuleUart.c
//*
//* 文件描述 : UART任务
//*
//* 作    者 : 
//* 版    本 : 
//* 编 译 器 : IAR EWARM 5.20
//*********************************************************************************************************
//*
#include "ModuleUart.h"
#include "led.h"
#include "msg_def.h"
#include "ModuleScr.h"
#include "common.h"
static PUARTDATA m_UartData=NULL;
BOOLEAN ModuleUartInit(void* pArg)
{
    BOOLEAN ret = TRUE;
    PMODULEUARTDATA pData = (PMODULEUARTDATA)pArg;
	  
	
    if(pData != NULL)
    {
				m_UartData = pData->m_pData;
				m_UartData->m_MarkSta = FALSE;
				m_UartData->m_index = 0;
        m_UartData->m_MarkIndex = 0;
			  pData->m_pAdArr = pData->m_pSysData->pStatus->m_AdArr;
			  
		}
    return ret;
}

BOOLEAN ModuleUartReset(void* pArg)
{
   BOOLEAN ret = TRUE;
    PMODULEUARTDATA pData = (PMODULEUARTDATA)pArg;
    pData->m_PressSta = FALSE;
    
    return ret;
}

BOOLEAN ModuleUartStart(void* pArg)
{
   BOOLEAN ret = TRUE;
    PMODULEUARTDATA pData = (PMODULEUARTDATA)pArg;
    pData->m_PressSta = TRUE;
	  pData->m_Count = 0;
	  pData->UsartSendFlag=0;
	  pData->m_50msCount=0;
	  //
	  
	 
    return ret;
}

BOOLEAN ModuleUartStop(void* pArg)
{
   BOOLEAN ret = TRUE;
    PMODULEUARTDATA pData = (PMODULEUARTDATA)pArg;
    pData->m_PressSta = FALSE;
    return ret;
}

BOOLEAN ModuleUartRelease(void* pArg)
{
   BOOLEAN ret = TRUE;
    PMODULEUARTDATA pData = (PMODULEUARTDATA)pArg;
    if(pData != NULL)
      free(pData);
    return ret;
}
void ModuleUart10msProcess(void* pArg)
{
    PMODULEUARTDATA pData = (PMODULEUARTDATA)pArg;
	  
}


void ModuleUart50msProcess(void* pArg)
{
    PMODULEUARTDATA pData = (PMODULEUARTDATA)pArg;
	  return;
}

void SendAdData(void* pArg)
{
    PMODULEUARTDATA pData = (PMODULEUARTDATA)pArg;
		INT8U data[17];
		INT16U val=0;
		data[0] = 0xfe;

// 		val = pData->m_pAdArr[0];	
// 		data[1] = (val & 0xff00)>>8;
// 		data[2] =  val & 0x00ff;
// 		val = pData->m_pAdArr[1];
// 		data[3] = (val & 0xff00)>>8;
// 		data[4] = val & 0x00ff;
// 		val = pData->m_pAdArr[2];
// 		data[5] = (val & 0xff00)>>8;
// 		data[6] = val & 0x00ff;
// 		val = pData->m_pAdArr[3];
// 		data[7] = (val & 0xff00)>>8;
// 		data[8] = val & 0x00ff;
// 		val = pData->m_pAdArr[4];
// 		data[9] = (val & 0xff00)>>8;
// 		data[10] = val & 0x00ff;
// 		val = pData->m_pAdArr[5];
// 		data[11] = (val & 0xff00)>>8;
// 		data[12] = val & 0x00ff;
// 		val = pData->m_pAdArr[6];
// 		data[13] = (val & 0xff00)>>8;
// 		data[14] = val & 0x00ff;		
// 		data[15] = SendADPKGCheckSum(&data[1],15);
//     data[16] = 0xef;
		//printf("SendAd:");
		//for(val=0;val<17;val++)
		//{
		//	printf(" 0x%x",data[val]);
		//}
		//printf("\r\n");
 		//UartSendData(data,17);	
}

INT8U SendADPKGCheckSum(INT8U* pData, INT8U num)
{
    INT8U ret =0;
    INT8U index =0;
    for(index=0;index<num;index++)
    {
        ret +=pData[index];
    }
    return ret;
}

void ModuleUart1sProcess(void* pArg)
{
    PMODULEUARTDATA pData = (PMODULEUARTDATA)pArg;
		INT16U index;
    //printf("ModuleUart1sProcess\r\n");
    if(pData->m_PressSta == FALSE)
		{
			return;
		}
      pData->m_Count++;
      pData->m_Led_Count++;
  	  LED(pData->m_Led_Count %2);//系统灯闪烁
		  //Buzze(pData->m_Led_Count %2);
		 
		  if(pData->m_Count>60)
			{
				pData->m_Count=0;
			}
//      
	
}

void UartMsgNotify(void* pArg, INT8U MsgId, INT16U lParam, INT16U wParam, void* pBuf) //消息处理
{
    
    switch(MsgId)
    {
        case MS_KEY_TRIGER:
          if(lParam == 1)
          {
						//printf("wParam：%d !!!\n",wParam);
            //立即执行配置保存，调用处理函数
						 Usart3SendDataToMaster(pArg, wParam);//发送串口消息到主控板
          }
          break;
        default:break;
    }
//     printf("Receive MSG !!!\n");
    
}

PMODULEBASE CreateModuleUart(PMODULESERVERDATA pServerData)
{
  PMODULEUART pModUart = NULL;
  PMODULEUARTDATA pData = NULL;

  pModUart = (PMODULEUART)malloc(sizeof(MODULEUART));//申请基类结构
  pData = (PMODULEUARTDATA)malloc(sizeof(MODULEUARTDATA));//申请基类数据结构
	pData->m_pData = NULL;
  pData->m_pData = (PUARTDATA)malloc(sizeof(UARTDATA));
	pData->m_pSysData = pServerData->m_pSysData;
//   ASSERT(pData->m_pData != NULL);
//   ASSERT(pModUart != NULL);
//   ASSERT(pData != NULL);
  pData->m_pMsgQueue = pServerData->m_pMsgQueue;
  pModUart->m_pBaseData = (PVOID)pData;
  
    //************************以下模块接口必须赋值******************************
  pModUart->pModeleInit = ModuleUartInit; //实现模块初始化
  pModUart->pModeleReset = ModuleUartReset; //实现模块复位
  pModUart->pModeleStart = ModuleUartStart; //实现模块开始
  pModUart->pModeleStop = ModuleUartStop; //实现模块结束
  pModUart->pModeleRelease = ModuleUartRelease;//实现
  pModUart->pMsgNotify = UartMsgNotify;//实现消息队列处理
  pModUart->pModele10msProcess = ModuleUart10msProcess;//不实现，置为NULL
  pModUart->pModele50msProcess = ModuleUart50msProcess;//不实现，置为NULL
  pModUart->pModele1sProcess = ModuleUart1sProcess;//实现1s调用 
	pModUart->pModele1msProcess = NULL;//实现1s调用 
	
  strcpy(pModUart->m_ModName, "ModUart");
	pModUart->pStart = Start;
  printf("CreateModuleUart!!\n");
  return (PMODULEBASE)pModUart;
}

void Start(void* pArg)
{
    while(1)
    {
        OSTimeDlyHMSM(0, 0, 0, 20);
				GetUartData(pArg);
    }
}

void GetUartData(void* pArg)
{
    PMODULEUARTDATA pData = (PMODULEUARTDATA)pArg;
// 	printf("---GetUartData\r\n");
    if(pData->m_pData->m_Sta == TRUE)
    {
        pData->m_pData->m_Sta = FALSE;
         
        Unpack(pArg, pData->m_pData->m_buf, BUFMAX );
    }
}

void SendUartData(uint16_t data)
{   
    INT8U i=0;
		INT16U len;
// 	
 	//printf("%d ",data); //tommy
   
    if(m_UartData == NULL)
        return;
   
    if(m_UartData->m_index >= DATABUF)
    {
        m_UartData->m_index = 0;
			  m_UartData->m_MarkIndex = 0;
        m_UartData->m_MarkSta = FALSE;
			 // printf("------649\r\n");
    }   

    m_UartData->m_DataBuf[m_UartData->m_index] = data;

    if(m_UartData->m_DataBuf[m_UartData->m_index] == SOM && m_UartData->m_MarkSta == FALSE)
    {
        m_UartData->m_MarkIndex = m_UartData->m_index;
        m_UartData->m_MarkSta = TRUE;
			 // printf("------658\r\n");
    }

    if(m_UartData->m_DataBuf[m_UartData->m_index] == EOM  && m_UartData->m_DataBuf[m_UartData->m_MarkIndex] == SOM )
    {
        len = m_UartData->m_index - m_UartData->m_MarkIndex + 1;	
// 				PD(m_UartData->m_index);
// 				PD(m_UartData->m_MarkIndex);
// 				PD(len);
			  // printf("------667\r\n");
        if(len == BUFMAX && CheckSum( &(m_UartData->m_DataBuf[m_UartData->m_MarkIndex]), len))
        {
            for(i=0; i<BUFMAX; i++)
            {
                m_UartData->m_buf[i] = m_UartData->m_DataBuf[m_UartData->m_MarkIndex+i];
            }
// 						PS("SendUartData");
            m_UartData->m_Sta = TRUE;  
            m_UartData->m_index = 0;
            m_UartData->m_MarkIndex = 0;
            m_UartData->m_MarkSta = FALSE;
        }
    }
    m_UartData->m_index++; 
}

void DataProcess(INT16U *pSrc, INT16U *pDis, INT8U len)
{
	INT8U i=0;
	for(i=0;i<len;i++)
	{
		pDis[i] = pSrc[i];
	}
}

////////CMD BYTE define/////////////
#define CMD_CALC_START 1
#define CMD_SET_VREF 2
#define CMD_AD_VAL 3
#define CMD_TEMP_VAL 4
#define CMD_CALC_STOP 5

#define CMD_BYTE 1
#define VAL_BYTE 2
#define DATA_BYTE 3
void Unpack(void* pArg, INT16U *pData, INT8U len)
{
    PMODULEUARTDATA pObjData = (PMODULEUARTDATA)pArg;
    INT8U i;
		INT16U val;
		PSYSTEMCONFIGDATA pSysData = pObjData->m_pSysData->pSys;
		INT16U PointNo = 0;
//  	  printf("Receive DATA: ");
//  		for(i=0;i<len;i++)
//  		{
//  			printf("0x%x ",pData[i]);
//  		}
     //printf("TOMMY\r\n");

		switch(pData[CMD_BYTE])
		{
			case 1://数据
				   pObjData->m_pSysData->m_FocusStatus = NoFocus;
           if ((pData[2] & BIT1) != 0) //检查x位是否为1
					 {
						 pObjData->m_pSysData->m_FocusStatus = Temp1Focus; //功能按钮在体温设置1
					 }
					 if ((pData[2] & BIT2) != 0) //检查x位是否为1
					 {
						 pObjData->m_pSysData->m_FocusStatus = Temp2Focus; //功能按钮在水温设置
					 }
					 if((pData[2] & BIT3) != 0) //检查x位是否为1
					 {
						 pObjData->m_pSysData->m_FocusStatus= TempWFocus; //功能按钮在体温设置2
					 }
					 pObjData->m_pSysData->m_Cycle1Set= (pData[2] & BIT4)>>4; //4水路1
					 pObjData->m_pSysData->m_Bump1Status = (pData[2] & BIT5)>>5;  //5水泵1
					 pObjData->m_pSysData->m_Cycle2Set= (pData[2] & BIT6)>>6;  //6水路2
					 pObjData->m_pSysData->m_Bump2Status = (pData[2] & BIT7)>>7;  //7水泵2
					 
					 //----------------------------------
					 //体温设置1
					 pObjData->m_pSysData->m_Temp1Set=(pData[3]<<8)+(pData[4]);
					  //水温设置
					 pObjData->m_pSysData->m_WaterTempSet=(pData[5]<<8)+(pData[6]);
           //体温设置2
					 pObjData->m_pSysData->m_Temp2Set=(pData[7]<<8)+(pData[8]);
					 
					  //体温1
					 pObjData->m_pSysData->m_Temp1=(pData[9]<<8)+(pData[10]);
					  //水温
					 pObjData->m_pSysData->m_WaterTemp=(pData[11]<<8)+(pData[12]);
           //体温2
					 pObjData->m_pSysData->m_Temp2=(pData[13]<<8)+(pData[14]);

					 pObjData->m_pSysData->m_SystemSta = pData[15]; //设置模式
					
					 //制热状态	Status_Off = 0,	Status_On = 1,	显示太阳
					 pObjData->m_pSysData->m_Heater=Status_Off ;
					pObjData->m_pSysData->m_Cooler=Status_Off;
					if(pData[16]==3 )  //制热模式 显示太阳3制热,2是制冷 1是关
					{
						 pObjData->m_pSysData->m_Heater=Status_On;
					}
					if(pData[16]==2) //制冷状态		显示雪花
					{
						 pObjData->m_pSysData->m_Cooler=Status_On;
					}	
					 //水位
					pObjData->m_pSysData->m_WaterStatus = pData[17];
					
					pObjData->m_pSysData->m_SystemAlm	= pData[18];				
				break;
			case 2://确认包			
				break;

			default:
				 break;
		}	
}

BOOLEAN CheckSum(INT16U* buf, INT8U len)
{
    INT8U index = 0;
    BOOLEAN ret = FALSE;
    INT8U sum=0;
    for(index=1;index<len-2;index++)
    {
// 			printf("0x%x ", buf[index]);
        sum+=buf[index];
    }
// 		PD(sum);
// 		PD(buf[len-2]);
    if(sum == buf[len-2])
        ret = TRUE;
    return ret;
}

void Usart3SendDataToMaster(void* pArg,uint8_t keyNumber)//发送串口消息到主控板
{
	  PMODULEUARTDATA pData = (PMODULEUARTDATA)pArg;
	      uint16_t len=8; 
	      uint8_t Comp_Cur_INS[8]={0xef,0x01,0x01,0x01,0x01,0x00,0x04,0xFF};

				Comp_Cur_INS[1]=0xa1;
				Comp_Cur_INS[2]=keyNumber;
				Comp_Cur_INS[3]=0x02;
			  Comp_Cur_INS[4]=0x03;
			  Comp_Cur_INS[5]=0x04;
				Comp_Cur_INS[6]=Comp_Cur_INS[1]+Comp_Cur_INS[2]+Comp_Cur_INS[3]+Comp_Cur_INS[4]+Comp_Cur_INS[5];
    	Comp_Cur_INS[7]=0xFF;
			Usart3SendData(Comp_Cur_INS, len);
}






