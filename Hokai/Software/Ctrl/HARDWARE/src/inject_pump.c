#include "inject_pump.h"
#include "ModulePump.h"
#include "stdio.h"
#include "string.h"


/*
****************************************************************************************
*函数名：Pump_Delay_1ms
*作  用：泵模块内部延迟函数
*形  参：需要延迟的时间（单位ms）
*返回值：无
*备  注：需要定时器1ms定时的配合
****************************************************************************************
*/
static void Pump_Delay_1ms(u8 delay_ms)
{
	PUMP_1MS_CNT=0;
	while(PUMP_1MS_CNT <= delay_ms);//2ms定时器里边对KEY_1MS_CNT进行了加一操作，不会死循环
}
/*
****************************************************************************************
*函数名：Clear_USART2_RxBuffer
*作  用：清空串口通讯接收缓存
*形  参：无
*返回值：无
*备  注：
****************************************************************************************
*/
static void Clear_USART2_RxBuffer(void)
{
	u8 i=0;	
	for(i=0;i<=USART5_Rx;i++)	USART5_RxBuffer[i]=0;	//清空缓存，重新接收
	USART5_Rx=0;
}

/*
****************************************************************************************
*函数名：Open_Communication_Mode
*作  用：打开与泵的通讯模式
*形  参：无
*返回值：操作状态=成功-------------------------------------------------------返回1
*				 					注射泵指令缓存溢出，所发指令被抛弃，需要重新发送指令-------返回2
*				 					失败-------------------------------------------------------返回0
*备  注：
****************************************************************************************
*/
extern  u8 Open_Communication_Mode(void)
{
	Clear_USART2_RxBuffer();
	printf("RS232=HOKAI%c\r\n",0xE5);										//打开通讯模式（命令+校验码+回车换行）	
	Pump_Delay_1ms(100);														
	if(strstr((char*)USART5_RxBuffer,"PWORD=") != NULL)	//打开通讯模式成功
	{		
		return 1;
	}
	if(strstr((char*)USART5_RxBuffer,"OFLOW") != NULL)	//注射泵指令缓存溢出，所发指令被抛弃
	{		
		return 2;
	}
	return 0;
}

/*
****************************************************************************************
*函数名：Close_Communication_Mode
*作  用：关闭与泵的通讯模式
*形  参：无
*返回值：操作状态=成功-------------------------------------------------------返回1
*				 					注射泵指令缓存溢出，所发指令被抛弃，需要重新发送指令-------返回2
*				 					失败-------------------------------------------------------返回0
*备  注：由于泵的一分钟内不通讯就自动关闭特性，在这里可以不在乎是否成功
****************************************************************************************
*/
extern  u8 Close_Communication_Mode(void)
{
	Clear_USART2_RxBuffer();
	printf("RS232=0%c\r\n",0xA9);												//打开通讯模式（命令+校验码+回车换行）	
	Pump_Delay_1ms(25);														
	if(strstr((char*)USART5_RxBuffer,"CMERR") == NULL)	//打开通讯模式成功
	{		
		return 1;
	}
	if(strstr((char*)USART5_RxBuffer,"OFLOW") != NULL)	//注射泵指令缓存溢出，所发指令被抛弃
	{		
		return 2;
	}
	return 0;
}
/*
****************************************************************************************
*函数名：Set_Channel
*作  用：设置通道号
*形  参：要打开的通道号
*返回值：操作状态=打开通讯方式失败-------------------------------------------返回0
*				 					成功-------------------------------------------------------返回1
*				 					失败-------------------------------------------------------返回2
*				 					注射泵指令缓存溢出，所发指令被抛弃，需要重新发送指令-------返回3
*				 					发出的指令错误---------------------------------------------返回8
*				 					无法识别返回指令-------------------------------------------返回9
*备  注：
****************************************************************************************
*/
extern  u8 Set_Channel(u8 channel)
{	
	if(Open_Communication_Mode() == SUCCESS)						//打开通讯模式成功
	{	
		Clear_USART2_RxBuffer();
		printf("CHANN=%d%c\r\n",channel,(0xD5 + channel));
		Pump_Delay_1ms(100);														
		if(strstr((char*)USART5_RxBuffer,"OK") != NULL)		//设置通道成功
		{		
			return 1;
		}
		if(strstr((char*)USART5_RxBuffer,"No") == NULL)		//设置通道失败
		{		
			return 2;
		}
		if(strstr((char*)USART5_RxBuffer,"OFLOW") != NULL)//注射泵指令缓存溢出，所发指令被抛弃
		{		
			return 3;
		}
		if(strstr((char*)USART5_RxBuffer,"CRERR") != NULL)//注射泵无法识别的指令
		{		
			return 8;
		}
		return 9;
	}
	return 0;
}
